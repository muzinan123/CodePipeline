# Purpose: AutoDocs is now API driven and the JSON payload needs to be sent to AutoDocs
# TODO: Consider parsing response for relevant data - currently would just be the request ID
# TODO: May need to inject AMI IDs in this step

version: 0.2

env:
  shell: bash
  variables: 
    token_bearer: token_bearer_okta.json
    response_autodoc: response_autodoc.json
    header_okta: okta.header
    header_autodoc: autodoc.header
    autodoc_urls: test/autodocs/autodoc_urls.json
    autodocreport: autoDocsValidation.json
    timeoutThreshold: 20
    metadataReportStatus: 1
  secrets-manager:
    pclient_id: tec/golden-ami/autodocs/auth:client_id
    pclient_secret: tec/golden-ami/autodocs/auth:client_secret

phases:
  pre_build:
    on-failure: ABORT
    commands:
      - echo "Fetcting Okta Url ..."
      - export okta_endpoint=$(jq -r .okta_endpoint ${autodoc_urls})
      - echo ${okta_endpoint}
      - echo "Fetcting AutoDoc Url for $Environment .."
      - export autodocs_endpoint=$(jq -r .autodocs_endpoint test/autodocs/autodoc_urls.json)
      - echo ${autodocs_endpoint}
      - AutoDocArtifactVariable="\$CODEBUILD_SRC_DIR_${AutoDocArtifactName}"
      - AutoDocArtifactPath=$(eval "echo $AutoDocArtifactVariable")
      - export rawdata_autodoc=${AutoDocArtifactPath}/${autodocreport}
  build:
    commands:
      - echo "AutoDocs Verification" 

      # Preparing Okta ASA payload 
      - echo "Generating headers for Okta ..."
      - |
          export auth_header=$(echo -n "${pclient_id}:${pclient_secret}" | base64 -w0)
          echo "Content-Type: application/x-www-form-urlencoded" > ${header_okta}
          echo "Authorization: Basic ${auth_header}" >> ${header_okta}
          echo "Accept-Charset: UTF-8" >> ${header_okta}
      - cat ${header_okta}

      # Okta ASA Authentication for AutoDocs API
      - echo "Fetching bearing token ..."
      - curl --location --request POST -H @$header_okta ${okta_endpoint} -o ${token_bearer}
      - export token=$(jq -r .access_token ${token_bearer})

      # Preparing AutoDocs payload
      - echo "Generating headers for AutoDocs ..."
      - |
          echo "Content-Type: application/json" > ${header_autodoc}
          echo "Authorization: Bearer ${token}" >> ${header_autodoc}
      - cat ${header_autodoc}

      # AutoDocs invocation
      - echo "Sending payload to AutoDocs for Verification ..."
      - curl --location --request POST -H @$header_autodoc ${autodocs_endpoint} -o ${response_autodoc} --data "$(cat ${rawdata_autodoc})"
      - cat ${response_autodoc}

      # Metadata from the request
      - export accountId=$(jq -r '.AccountId' ${response_autodoc})
      - export accountName=$(jq -r '.AccountName' ${response_autodoc})

      # IQOQ Metadata Verification
      - export metadataS3Bucket=$(jq -r '.MetadataFile.Bucket' ${response_autodoc})
      - export metadataS3Key=$(jq -r '.MetadataFile.Filename' ${response_autodoc})
      - export timeoutCount=0
      - export localFileName=${metadataS3Key##*/}
      
      # - | 
      #     echo "Checking for metadata report generated by AutoDocs"
      #     while [[ metadataReportStatus != 1 ]]; do
      #       if [[ $timeoutCount -eq $timeoutThreshold ]] ; then
      #         echo "Attempted $timeoutCount times to find report, s3://${metadataS3Bucket}/${metadataS3Key}"
      #         echo "Verification Terminated. No report generated. "
      #         exit 124
      #       fi

      #       aws s3 ls s3://${metadataS3Bucket}/${metadataS3Key}
      #       metadataReportStatus=$(echo $?)

      #       if [[ ${metadataReportStatus} == '0' ]]; then
      #         echo "Downloading the generated report..."
      #         aws s3 cp s3://${metadataS3Bucket}/${metadataS3Key} .
      #         break
      #       else
      #         (( timeoutCount++ ))

      #         echo "Metadata is not yet available..."
      #         echo "Retrying in 30 seconds..."
      #         echo $timeoutCount
      #         sleep 30
      #       fi
      #     done

      #     totalPass=$(jq -r '.totalpass' $localFileName)
      #     totalFail=$(jq -r '.totalfail' $localFileName)

      #     echo "AutoDocs Results:"
      #     echo "Passed Test Cases: ${totalPass}"
      #     echo "Failed Test Cases: ${totalFail}"

      #     if [[ ${totalFail} > 0 ]]; then
      #       echo "AMI failed the AutoDocs Verification..."
      #       exit 1
      #     else 
      #       echo 'AMI passed the AutoDocs Verification'
      #     fi

      # IQOQ Report Verification
      - reportS3Bucket=$(jq -r '.ReportFile.Bucket' ${response_autodoc})
      - reportS3Key=$(jq -r '.ReportFile.Filename' ${response_autodoc})
      - export timeoutCount=0
      # - | 
      #     echo "Checking for IQOQ report generated by AutoDocs"
      #     while [[ metadataReportStatus != 1 ]]; do
      #       if [[ $timeoutCount -eq $timeoutThreshold ]] ; then
      #         echo "Attempted $timeoutCount times to find IQOQ report, s3://${reportS3Bucket}/${reportS3Key}"
      #         echo "Verification Terminated. No IQOQ report generated. "
      #         exit 124
      #       fi

      #       aws s3 ls s3://${reportS3Bucket}/${reportS3Key}
      #       metadataReportStatus=$(echo $?)

      #       if [[ ${metadataReportStatus} == '0' ]]; then
      #         echo "Downloading the generated report..."
      #         aws s3 cp s3://${reportS3Bucket}/${reportS3Key} .
      #         break
      #       else
      #         (( timeoutCount++ ))

      #         echo "IQOQ report is not yet available..."
      #         echo "Retrying in 30 seconds..."
      #         sleep 30
      #       fi
      #     done
      - |
          echo "The report can be found in tec-cpe-shs-prd, 012096835438 ..."
      - | 
          echo "Report S3 Bucket: ${reportS3Bucket}"
      - | 
          echo "Report S3 Key: ${reportS3Key}"

artifacts:
  files:
    # AutoDoc reponse
    - ${response_autodoc}
    # Commenting out until download section is used
    # - $localFileName
  discard-paths: yes